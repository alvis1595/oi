################## catalogos ############################################33
CREATE OR REPLACE FUNCTION obtener_catalogos()
RETURNS JSONB AS $$
DECLARE
    tablas TEXT[] := ARRAY[
        'cis_alojamiento', 'cis_desarrollo', 'cis_entorno_ci', 
        'cis_lenguaje', 'cis_nombre_aplicacion', 'cis_pais_servidor',
        'cis_proveedor', 'cis_responsable_aplicacion', 'cis_tipo_servidor',
        'cis_esquema', 'cis_estrategias_infra', 'cis_estrategias_datos',
        'cis_tiempo_infra_servidor', 'cis_tiempo_infra_aplicacion', 
        'cis_joya'
    ];
    resultado JSONB := '[]'::JSONB;  -- Iniciar un arreglo vacío
    fila JSONB;
BEGIN
    -- Iterar sobre cada tabla en el array de tablas
    FOREACH consulta IN ARRAY tablas LOOP
        -- Ejecutar la consulta y agregar el resultado como una lista
        EXECUTE format('SELECT json_agg(t) FROM %I t', consulta)
        INTO fila;
        
        -- Asegurarse de que fila no sea nula y agregarla a la lista de resultados
        resultado := resultado || COALESCE(fila, '[]'::jsonb);
    END LOOP;

    RETURN resultado;
END;
$$ LANGUAGE plpgsql;


@cmdb.route('/cmdb/catalog', methods=['GET'])
@require_api_key
def catalogos():
    if request.method == 'GET':
        connection = None
        result2 = []
        try:
            # Conectar a la base de datos
            connection = psycopg2.connect(user=db_User,
                                          password=db_Pass,
                                          host=db_Host,
                                          port=db_Port,
                                          database="cmdb_integracion")
            cursor = connection.cursor()
            
            # Ejecutar la función de PostgreSQL
            cursor.execute("SELECT obtener_catalogos();")
            result = cursor.fetchone()[0]  # Obtener el resultado en formato JSON
            
            # El resultado ya está en la forma de una lista de listas, asignarlo directamente
            result2 = result  
            
            logging.info(json.dumps(result2))
        except Error as e:
            logging.error(f"[ERROR]: Algo ha salido mal: {e.pgerror}")
        finally:
            if connection:
                cursor.close()
                connection.close()
                
    # Devolver el JSON correctamente al frontend
    return json.dumps(result2, ensure_ascii=False).encode('utf8')


##############################################################################################################################

Add catalogo
CREATE OR REPLACE FUNCTION add_catalog_item(
    catalog_name TEXT,
    value TEXT
) RETURNS TEXT AS $$
DECLARE
    table_name TEXT;
    column_name TEXT;
    check_query TEXT;
    exists_count INT;
BEGIN
    -- Mapeo de catálogos a tablas y columnas
    IF catalog_name = 'Alojamiento' THEN
        table_name := 'cis_alojamiento';
        column_name := 'ca_tipo_alojamiento';
    ELSIF catalog_name = 'Desarrollo' THEN
        table_name := 'cis_desarrollo';
        column_name := 'cd_desarrollo';
    ELSIF catalog_name = 'Entorno' THEN
        table_name := 'cis_entorno_ci';
        column_name := 'cec_tipo';
    ELSIF catalog_name = 'Lenguaje' THEN
        table_name := 'cis_lenguaje';
        column_name := 'cl_lenguaje';
    ELSIF catalog_name = 'Aplicacion' THEN
        table_name := 'cis_nombre_aplicacion';
        column_name := 'cna_aplicacion';
    ELSIF catalog_name = 'Pais' THEN
        table_name := 'cis_pais_servidor';
        column_name := 'cps_servidor';
    ELSIF catalog_name = 'Proveedor' THEN
        table_name := 'cis_proveedor';
        column_name := 'cp_proveedor';
    ELSIF catalog_name = 'Responsable' THEN
        table_name := 'cis_responsable_aplicacion';
        column_name := 'cra_mesa';
    ELSIF catalog_name = 'Tipo Servidor' THEN
        table_name := 'cis_tipo_servidor';
        column_name := 'cts_tipo_servidor';
    ELSIF catalog_name = 'Esquema de Continuidad' THEN
        table_name := 'cis_esquema';
        column_name := 'ce_esquema';
    ELSIF catalog_name = 'Estrategias de Recuperación Infra' THEN
        table_name := 'cis_estrategias_infra';
        column_name := 'cei_estrategias';
    ELSIF catalog_name = 'Estrategias de Recuperación Datos' THEN
        table_name := 'cis_estrategias_datos';
        column_name := 'ced_estrategias';
    ELSIF catalog_name = 'Tiempo de Instalación (Servidor)' THEN
        table_name := 'cis_tiempo_infra_servidor';
        column_name := 'ctis_tiempo';
    ELSIF catalog_name = 'Tiempo de Instalación (Aplicación)' THEN
        table_name := 'cis_tiempo_infra_aplicacion';
        column_name := 'ctia_tiempo';
    ELSIF catalog_name = 'Joya de la Corona' THEN
        table_name := 'cis_joya';
        column_name := 'cj_joya';
    ELSE
        RETURN 'ERROR: Catálogo no reconocido.';
    END IF;

    -- Verifica si el valor ya existe en la tabla
    check_query := FORMAT('SELECT COUNT(*) FROM %I WHERE %I = $1', table_name, column_name);
    EXECUTE check_query INTO exists_count USING value;

    IF exists_count > 0 THEN
        RETURN 'ERROR: El dato ya existe en el catálogo.';
    END IF;

    -- Inserta el nuevo valor
    EXECUTE FORMAT('INSERT INTO %I (%I) VALUES ($1)', table_name, column_name) USING value;

    RETURN 'Se agregó el registro correctamente!';
END;
$$ LANGUAGE plpgsql;
----------------------------------------------------------------------------- api
@cmdb.route('/cmdb/add_catalog', methods=['POST'])
@require_api_key
def addCatalog():
    if request.method == 'POST':
        errorcode = 0
        errormsg = ""
        result = None
        connection = None

        value = request.form.get('value').replace('"', '') 
        catalogo = request.form.get('tabValue').replace('"', '') 
        
        try:
            connection = psycopg2.connect(user=db_User,
                                          password=db_Pass,
                                          host=db_Host,
                                          port=db_Port,
                                          database="cmdb_integracion")
            cursor = connection.cursor()

            # Llama a la función almacenada en PostgreSQL
            cursor.execute("SELECT add_catalog_item(%s, %s)", (catalogo, value))
            result = cursor.fetchone()[0]  # Obtiene el resultado devuelto por la función

            connection.commit()

        except psycopg2.DatabaseError as e:
            logging.error(f"[ERROR]: Algo ha salido mal al intentar guardar: {e.pgerror}")
            errorcode = 1
            errormsg = f"ERROR: {e.pgerror}"  # Establecer el mensaje de error
        finally:
            if connection:
                cursor.close()
                connection.close()
        
        # Devuelve el resultado en el formato esperado
        return jsonify({
            "errorcode": errorcode,
            "errormsg": errormsg,
            "result": result if result else "No se ha agregado ningún registro."
        })
###############################################################################################################################
api remover

@cmdb.route('/cmdb/delete_catalog', methods=['POST'])
@require_api_key
def deleteCatalog():
    if request.method == 'POST':
        connection = None
        errorcode = 0
        errormsg = ""

        # Obtener los valores enviados desde el frontend
        id = (request.form.get('id').replace('"',''))  # Valor a eliminar
        catalogo = (request.form.get('cat').replace('"',''))  # Nombre del catálogo

        try:
            # Establecer conexión con la base de datos
            connection = psycopg2.connect(user=db_User,
                                          password=db_Pass,
                                          host=db_Host,
                                          port=db_Port,
                                          database="cmdb_integracion")
            cursor = connection.cursor(cursor_factory=RealDictCursor)

            # Llamar a la función SQL de PostgreSQL para eliminar el registro
            cursor.callproc('remove_catalog_item', (catalogo, id))

            # Commit de la transacción
            connection.commit()

        except Error as e:
            logging.error(f"[ERROR]: Algo ha salido mal al intentar eliminar: {e.pgerror}")
            errormsg = f"ERROR: {e.pgerror}"
            errorcode = 1
        finally:
            if connection:
                cursor.close()
                connection.close()

        # Si hubo un error, responde con el mensaje de error
        if errorcode != 0:
            return jsonify({"error": errormsg}), 400
        # Si no hubo error, responde con el resultado
        else:
            return jsonify({"result": "Se eliminó el registro correctamente!"})
